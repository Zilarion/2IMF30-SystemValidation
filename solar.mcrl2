% --------------------
% Sort declarations
% --------------------
sort 
	sPedalState = struct Pressed | Released;
	sDNRPState = struct D | R | NP;
	sOnOffButton = struct SwitchOn | SwitchOff;
	sBatteryState = struct Unsafe | Safe | Full;
	sCCThreshold = struct BelowCCmin | AboveCCmin;
	sTurnOffThreshold = struct BelowTurnOffMax | AboveTurnOffMax;
	sDirection = struct Forwards | Backwards | Static;
	sCCState = struct Enabled | Disabled;
	sCCButton = struct Enable | Disable;
	sVirtualCarState = struct On | Off;

	
map opposite: sDirection -> sDirection;
eqn
	opposite(Forwards) = Backwards;
	opposite(Static) = Static;
	opposite(Backwards) = Forwards;

% --------------------
% Action declarations
% --------------------
act
	% Input actions from the user and environment
  	aGasPedal : sPedalState;
  	aBrakePedal : sPedalState;
  	aDNRP : sDNRPState;
  	aCar : sOnOffButton;
  	aBattery : sBatteryState;
  	aSpeed : sCCThreshold # sTurnOffThreshold # sDirection;
  	aCC : sCCButton;

  	% Output actions
  	aVCS : sVirtualCarState;
  	aMotorForce : sDirection;
	aCCActive: sCCState;

% --------------------
% Communication definitions
% --------------------
act s_VCS, r_VCS_steer, r_VCS_light, r_VCS_MF, c_VCS : sVirtualCarState;
act s_ccEnable, r_ccEnable_MF, c_ccEnable: sCCState;
act s_Battery, r_Battery_MF, c_Battery: sBatteryState;
% --------------------
% Safety Procedure
% --------------------
sort safetyState = struct safetyOn | safetyOff | safetyNull;

proc Safety(state:safetyState, target:safetyState) =
	% State changes
	(target != safetyNull) ->
		((target==safetyOn) ->
			s_VCS(On).aVCS(On)
		<>
		(target==safetyOff) ->
			s_VCS(Off).aVCS(Off)
		).Safety(state=target, target=safetyNull)
	
	% Car on/off button interactions
	+ (sum btn:sOnOffButton.aCar(btn).
		% The car is turned on
		(btn == SwitchOn && state==safetyOff) ->
			Safety(target=safetyOn)
		<> 
		% The car is turned off
		(btn == SwitchOff && state==safetyOn) ->
			Safety(target=safetyOff)
		<> 
		% We don't have to change anything
		Safety()
		)
	
	% Interactions only possible when uC is on
	+ (state==safetyOn) ->
		% Battery is unsafe, turn off!
		aBattery(Unsafe).Safety(target=safetyOff);


% --------------------
% Steering procedure
% --------------------
sort steeringState = struct steeringOn | steeringOff | steeringNull;

proc Steering(state:steeringState) =
	% Process state changes
	%(target != steeringNull) ->
	%	Steering(target, steeringNull)
	
	% Process messages
	sum data:sVirtualCarState.r_VCS_steer(data).(
		(data==On) ->
			Steering(steeringOn)
		<>	
		%(data==Off) ->
			Steering(steeringOff)	
	)
	
	% Interactions only possible when active
	+ (state==steeringOn) -> (
		% Cruise control interactions
		sum btn:sCCButton.aCC(btn).
			% Do request to turn CC on
			(btn==Enable) ->
				s_ccEnable(Enabled).Steering()
			<>
			% Do request to turn CC off			
			(btn==Disable) ->
				s_ccEnable(Disabled).Steering()
	);

% --------------------
% Drive procedure
% i_name -> input variable
% m_name -> state variable
% --------------------
proc MotorForce(m_vcs:sVirtualCarState, m_dnrp:sDNRPState, m_dir:sDirection, m_gas:sPedalState, m_brake:sPedalState, m_battery:sBatteryState, m_ccstate:sCCState) = 
	ApplyMotorForce(m_vcs, m_dnrp, m_dir, m_gas, m_brake, m_battery, m_ccstate).(
		sum i_vcs:sVirtualCarState.	r_VCS_MF(i_vcs).							MotorForce(m_vcs = i_vcs) + 
		sum i_ccstate:sCCState.			r_ccEnable_MF(i_ccstate).			MotorForce(m_ccstate = i_ccstate) + 
		sum i_dnrp:sDNRPState.			aDNRP(i_dnrp).								MotorForce(m_dnrp = i_dnrp) + 
		sum i_gas:sPedalState.			aGasPedal(i_gas).							MotorForce(m_gas = i_gas) + 
		sum i_brake:sPedalState.		aBrakePedal(i_brake).					MotorForce(m_brake = i_brake) + 
		sum i_battery:sBatteryState.r_Battery_MF(i_battery).			MotorForce(m_battery = i_battery) + 
		sum i_dir:sDirection.sum i_tot:sTurnOffThreshold.sum i_cct:sCCThreshold.
																aSpeed(i_cct, i_tot, i_dir).	MotorForce(m_dir = i_dir)
	);
	
proc ApplyMotorForce(m_vcs:sVirtualCarState, m_dnrp:sDNRPState, m_dir:sDirection, m_gas:sPedalState, m_brake:sPedalState, m_battery:sBatteryState, m_ccstate:sCCState) = 
	% Never drive when the car is Off, or when the battery is too emtpy (Unsafe)
	(m_vcs == Off || m_battery == Unsafe) -> 
		aMotorForce(Static)
	<> (m_ccstate == Enabled) ->
		% TODO Should we also check DNRP states when applying CC?
		% Note that CC module should also so this.
		% Second note: should we check on battery safety level?
		aMotorForce(Forwards)
	<> (m_dnrp == NP ) -> %from here on: m_vcs == On
		aMotorForce(Static)
	<> (m_dnrp == D) ->
		(m_brake == Pressed) -> %ignore gas
			(m_battery == Full) ->
				aMotorForce(Static)
			<>
				aMotorForce(opposite(m_dir))
		<> (m_gas == Pressed) -> % only gas is pressed
			(m_battery == Full && m_dir == Backwards) ->
				aMotorForce(Static)
			<>
				aMotorForce(Forwards)
		<> %Neither gas not brake is pressed
			aMotorForce(Static)
	<> %(m_dnrp == R)
		(m_brake == Pressed) -> %ignore gas
			(m_battery == Full) ->
				aMotorForce(Static)
			<>
				aMotorForce(opposite(m_dir))
		<> (m_gas == Pressed) -> % only gas is pressed
			(m_battery == Full && m_dir == Forwards) ->
				aMotorForce(Static)
			<>
				aMotorForce(Backwards)
		<> %Neither gas not brake is pressed
			aMotorForce(Static)
; %End of ApplyMotorForce

% --------------------
% Process definition
% --------------------

init
	allow({
		%Input actions 
  	aGasPedal,
  	aBrakePedal,
  	aDNRP,
  	aCar,
  	aBattery,
  	aSpeed,
  	aCC,
  	% Output actions
  	aVCS,
  	aMotorForce,
		aCCActive,
		% Communications
		c_VCS,
		c_ccEnable,
		c_Battery
		},
		comm(
		{ 
			s_VCS | r_VCS_steer | r_VCS_light | r_VCS_MF -> c_VCS,
			s_ccEnable | r_ccEnable_MF -> c_ccEnable,
			s_Battery | r_Battery_MF -> c_Battery
		},
		 MotorForce(Off, NP, Static, Released, Released, Full, Disabled) ||
		 Safety(safetyOff, safetyNull) || Steering(steeringOff)
		));
