% --------------------
% Sort declarations
% --------------------
sort 
	sPedalState = struct Pressed | Released;
	sDNRPState = struct D | R | NP;
	sOnOffButton = struct SwitchOn | SwitchOff;
	sBatteryState = struct Unsafe | Safe | Full;
	sCCThreshold = struct BelowCCmin | AboveCCmin;
	sTurnOffThreshold = struct BelowTurnOffMax | AboveTurnOffMax;
	sDirection = struct Forwards | Backwards | Static;
	sCCState = struct Enabled | Disabled;
	sCCButton = struct Enable | Disable;
	sVirtualCarState = struct On | Off;

	
map opposite: sDirection -> sDirection;
eqn
	opposite(Forwards) = Backwards;
	opposite(Static) = Static;
	opposite(Backwards) = Forwards;

% --------------------
% Action declarations
% --------------------
act
	% Input actions from the user and environment
  	aGasPedal : sPedalState;
  	aBrakePedal : sPedalState;
  	aDNRP : sDNRPState;
  	aCar : sOnOffButton;
  	aBattery : sBatteryState;
  	aSpeed : sCCThreshold # sTurnOffThreshold # sDirection;
  	aCC : sCCButton;
  	
  	% Output actions
  	% Use c_VCS and c_CCActive instead when writing checking formulas
  	%aVCS : sVirtualCarState;
  	aMotorForce : sDirection;
		%aCCActive: sCCState;
  	
% --------------------
% Communication definitions
% --------------------

  % All input actions are serialized via an InputHandler process
  % This serialization ensures that all parallel components
  % process the actions in the same order. Below are the
  % communication action definitions.
  	
  	c_GasPedal : sPedalState;
  	c_BrakePedal : sPedalState;
  	c_DNRP : sDNRPState;
  	c_Car : sOnOffButton;
  	c_Battery : sBatteryState;
  	c_Speed : sCCThreshold # sTurnOffThreshold # sDirection;
  	c_CC : sCCButton;
  	
  	s_GasPedal : sPedalState;
  	s_BrakePedal : sPedalState;
  	s_DNRP : sDNRPState;
  	s_Car : sOnOffButton;
  	s_Battery : sBatteryState;
  	s_Speed : sCCThreshold # sTurnOffThreshold # sDirection;
  	s_CC : sCCButton;
  	
  	r_GasPedal_MF, r_GasPedal_Steering : sPedalState;
  	r_BrakePedal_MF, r_BrakePedal_Steering : sPedalState;
  	r_DNRP_MF, r_DNRP_Steering : sDNRPState;
  	r_Car_Safety : sOnOffButton;
  	r_Battery_Safety : sBatteryState;
  	r_Battery_MF : sBatteryState;
  	r_Speed_MF, r_Speed_Safety, r_Speed_Steering : sCCThreshold # sTurnOffThreshold # sDirection;
  	r_CC_Steering : sCCButton;

		% Inter process communications
		act s_VCS, r_VCS_steer, r_VCS_MF, c_VCS : sVirtualCarState;
		act s_ccEnable, r_ccEnable_MF, c_ccEnable: sCCState;
		act r_InputHandled, s_MF_Done, s_Steering_Done, s_Safety_Done, c_InputHandled;


% --------------------
% Input Handler
% --------------------

proc InputHandler = 
(
sum gas:sPedalState.aGasPedal(gas).s_GasPedal(gas) +
sum brake:sPedalState.aBrakePedal(brake).s_BrakePedal(brake) +
sum dnrp:sDNRPState.aDNRP(dnrp).s_DNRP(dnrp) +
sum car:sOnOffButton.aCar(car).s_Car(car) +
sum batt:sBatteryState.aBattery(batt).s_Battery(batt) +
sum cc:sCCButton.aCC(cc).s_CC(cc) +
sum ccthr:sCCThreshold.sum onoffthr:sTurnOffThreshold.sum dir:sDirection.aSpeed(ccthr, onoffthr, dir).s_Speed(ccthr, onoffthr, dir)

%sum gas:sPedalState.s_GasPedal(gas) +
%sum brake:sPedalState.s_BrakePedal(brake) +
%sum dnrp:sDNRPState.s_DNRP(dnrp) +
%sum car:sOnOffButton.s_Car(car) +
%sum batt:sBatteryState.s_Battery(batt) +
%sum cc:sCCButton.s_CC(cc) +
%sum ccthr:sCCThreshold.sum onoffthr:sTurnOffThreshold.sum dir:sDirection.s_Speed(ccthr, onoffthr, dir)

).InputHandler;
	
% --------------------
% Safety Procedure
% --------------------

proc Safety(state:sVirtualCarState, battery:sBatteryState, onoffthrState:sTurnOffThreshold) =
	
	% State changes
	% s_VCS(state).Safety() +
	
	% Car on/off button interactions
	(sum btn:sOnOffButton.r_Car_Safety(btn).
		% Turn the car on
		(btn == SwitchOn && battery!=Unsafe) ->
			s_VCS(On).Safety(state=On)
		<> 
		% Turn the car off
		(btn == SwitchOff && onoffthrState == AboveTurnOffMax) ->
			s_VCS(Off).Safety(state=Off)
		<> 
		% We don't have to change anything
		Safety()
		)
		
	+ r_Battery_Safety(Unsafe).s_VCS(Off).Safety(state=Off, battery=Unsafe)
	+ r_Battery_Safety(Safe).Safety(battery=Safe)
	+ r_Battery_Safety(Full).Safety(battery=Full)
	
	+ sum ccthr:sCCThreshold.sum onoffthr:sTurnOffThreshold.sum dir:sDirection.
		r_Speed_Safety(ccthr, onoffthr, dir).Safety(onoffthrState = onoffthr)
	
	+ s_Safety_Done.Safety();

% --------------------
% Steering procedure
% --------------------

proc Steering(state:sVirtualCarState, ccthrState:sCCThreshold, enabled:Bool, dnrp:sDNRPState, gas:sPedalState, brake:sPedalState) =
	% Process messages
	sum data:sVirtualCarState.r_VCS_steer(data).((data == Off && enabled == true) -> (s_ccEnable(Disabled).Steering(state = Off, enabled = false)) <> Steering(state = data))
	
	+ sum i_gas:sPedalState.	r_GasPedal_Steering(i_gas).			
	(
		(i_gas == Pressed && enabled == true)	-> 
		(
			s_ccEnable(Disabled).Steering(gas = i_gas, enabled = false)
		) 
		<> 
			Steering(gas = i_gas)
	)
	+ sum i_brake:sPedalState.r_BrakePedal_Steering(i_brake).	
	(
		(i_brake == Pressed && enabled == true)-> 
		(
			s_ccEnable(Disabled).Steering(brake = i_brake, enabled = false)
		) 
		<> 
			Steering(brake = i_brake) 
	)
	+ sum i_dnrp:sDNRPState.r_DNRP_Steering(i_dnrp).Steering(dnrp = i_dnrp)
	
	+
	sum btn:sCCButton.r_CC_Steering(btn). 
	(state==On && ccthrState == AboveCCmin && dnrp == D && brake == Released) -> (		
			% Do request to turn CC on
			(btn==Enable) ->
				s_ccEnable(Enabled).Steering(enabled = true)
			<>
			% Do request to turn CC off			
			(btn==Disable) ->
				s_ccEnable(Disabled).Steering(enabled = false)
	) <>
	Steering()
	
	% Note that the ccthr only matter for enabling the CC.
	+ sum ccthr:sCCThreshold.sum onoffthr:sTurnOffThreshold.sum dir:sDirection.
		r_Speed_Steering(ccthr, onoffthr, dir).Steering(ccthrState = ccthr)
		
	+ s_Steering_Done.Steering();

% --------------------
% Drive procedure
% i_name -> input variable
% m_name -> state variable
% --------------------
proc MotorForce(m_vcs:sVirtualCarState, m_dnrp:sDNRPState, m_dir:sDirection, m_gas:sPedalState, m_brake:sPedalState, m_battery:sBatteryState, m_ccstate:sCCState) = 
	ApplyMotorForce(m_vcs, m_dnrp, m_dir, m_gas, m_brake, m_battery, m_ccstate).(
		sum i_vcs:sVirtualCarState.	r_VCS_MF(i_vcs).								MotorForce(m_vcs = i_vcs) + 
		sum i_ccstate:sCCState.			r_ccEnable_MF(i_ccstate).				MotorForce(m_ccstate = i_ccstate) + 
		sum i_dnrp:sDNRPState.			r_DNRP_MF(i_dnrp).							MotorForce(m_dnrp = i_dnrp) + 
		sum i_gas:sPedalState.			r_GasPedal_MF(i_gas).						MotorForce(m_gas = i_gas) + 
		sum i_brake:sPedalState.		r_BrakePedal_MF(i_brake).				MotorForce(m_brake = i_brake) + 
		sum i_battery:sBatteryState.r_Battery_MF(i_battery).				MotorForce(m_battery = i_battery) + 
		sum i_dir:sDirection.sum i_tot:sTurnOffThreshold.sum i_cct:sCCThreshold.
																r_Speed_MF(i_cct, i_tot, i_dir).MotorForce(m_dir = i_dir)
	)
	+ s_MF_Done.MotorForce();
	
proc ApplyMotorForce(m_vcs:sVirtualCarState, m_dnrp:sDNRPState, m_dir:sDirection, m_gas:sPedalState, m_brake:sPedalState, m_battery:sBatteryState, m_ccstate:sCCState) = 
	% Never drive when the car is Off, or when the battery is too emtpy (Unsafe)
	(m_vcs == Off || m_battery == Unsafe) -> 
		aMotorForce(Static)
	<> (m_ccstate == Enabled) ->
		% TODO Should we also check DNRP states when applying CC?
		% Note that CC module should also so this.
		% Second note: should we check on battery safety level?
		aMotorForce(Forwards)
	<> (m_dnrp == NP ) -> %from here on: m_vcs == On
		aMotorForce(Static)
	<> (m_dnrp == D) ->
		(m_brake == Pressed) -> %ignore gas
			(m_battery == Full) ->
				aMotorForce(Static)
			<>
				aMotorForce(opposite(m_dir))
		<> (m_gas == Pressed) -> % only gas is pressed
			(m_battery == Full && m_dir == Backwards) ->
				aMotorForce(Static)
			<>
				aMotorForce(Forwards)
		<> %Neither gas not brake is pressed
			aMotorForce(Static)
	<> %(m_dnrp == R)
		(m_brake == Pressed) -> %ignore gas
			(m_battery == Full) ->
				aMotorForce(Static)
			<>
				aMotorForce(opposite(m_dir))
		<> (m_gas == Pressed) -> % only gas is pressed
			(m_battery == Full && m_dir == Forwards) ->
				aMotorForce(Static)
			<>
				aMotorForce(Backwards)
		<> %Neither gas not brake is pressed
			aMotorForce(Static)
; %End of ApplyMotorForce

% --------------------
% Process definition
% --------------------

init
	hide({
		c_Battery,
		c_GasPedal,
		c_BrakePedal,
		c_DNRP,
		c_Car,
		c_Speed,
		c_CC,
		c_InputHandled
	},
	allow({
		%Input actions 
  	aGasPedal,
  	aBrakePedal,
  	aDNRP,
  	aCar,
  	aBattery,
  	aSpeed,
  	aCC,
  	% Output actions
  	%aVCS,
  	aMotorForce,
		%aCCActive,
		% Communications
		c_VCS,
		c_ccEnable,
		c_Battery,
		c_GasPedal,
		c_BrakePedal,
		c_DNRP,
		c_Car,
		c_Speed,
		c_CC,
		c_InputHandled
		},
		comm(
		{
			s_VCS | r_VCS_steer | r_VCS_MF -> c_VCS,
			s_ccEnable | r_ccEnable_MF -> c_ccEnable,
			s_GasPedal | r_GasPedal_MF | r_GasPedal_Steering -> c_GasPedal,
  		s_BrakePedal | r_BrakePedal_MF | r_BrakePedal_Steering	-> c_BrakePedal,
  		s_DNRP | r_DNRP_MF | r_DNRP_Steering -> c_DNRP,
  		s_Car | r_Car_Safety	-> c_Car,
  		s_Battery	| r_Battery_Safety	| r_Battery_MF	-> c_Battery,
  		s_Speed | r_Speed_MF | r_Speed_Safety | r_Speed_Steering	-> c_Speed,
  		s_CC | r_CC_Steering	-> c_CC,
  		r_InputHandled | s_MF_Done | s_Steering_Done | s_Safety_Done -> c_InputHandled
		},
		 MotorForce(Off, NP, Static, Released, Released, Full, Disabled) ||
		 Safety(Off, Safe, BelowTurnOffMax) || Steering(Off, BelowCCmin, false, NP, Released, Released) 
		 || InputHandler
		)));
