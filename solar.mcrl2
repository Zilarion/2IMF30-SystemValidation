% --------------------
% Sort declarations
% --------------------
sort 
	sPedalState = struct Pressed | Released;
	sDNRPState = struct D | R | NP;
	sOnOffButton = struct SwitchOn | SwitchOff;
	sBatteryState = struct Unsafe | Safe | Full;
	sCCThreshold = struct BelowCCmin | AboveCCmin;
	sTurnOffThreshold = struct BelowTurnOffMax | AboveTurnOffMax;
	sDirection = struct Forwards | Backwards | Static;
	sCCState = struct Enabled | Disabled;
	sCCButton = struct Enable | Disable;
	sVirtualCarState = struct On | Off;
	sBrakeLighting = struct LightOn | LightOff;

% --------------------
% Action declarations
% --------------------
act
	% Input actions from the user and environment
  	aGasPedal : sPedalState;
  	aBrakePedal : sPedalState;
  	aDNRP : sDNRPState;
  	aCar : sOnOffButton;
  	aBattery : sBatteryState;
  	aSpeed : sCCThreshold # sTurnOffThreshold # sDirection;
  	aCC : sCCButton;

  	% Output actions
  	aVCS : sVirtualCarState;
  	aMotorforce : sDirection;
	aBrakeLighting: sBrakeLighting;
	aCCActive: sCCState;

% --------------------
% Communication definitions
% --------------------
act s_VCS, r_VCS_steer, r_VCS_drive, r_VCS_light, c_VCS : sVirtualCarState;
act s_ccEnable, r_ccEnable, c_ccEnable: sCCState;
% --------------------
% Safety Procedure
% --------------------
sort safetyState = struct safetyOn | safetyOff | safetyNull;

proc Safety(state:safetyState, target:safetyState) =
	% State changes
	(target != safetyNull) ->
		((target==safetyOn) ->
			s_VCS(On).aVCS(On)
		<>
		(target==safetyOff) ->
			s_VCS(Off).aVCS(Off)
		).Safety(state=target)
	
	% Car on/off button interactions
	+ sum btn:sOnOffButton.aCar(btn).
		% The car is turned on
		(btn == SwitchOn && state==safetyOff) ->
			Safety(target=safetyOn)
		<> 
		% The car is turned off
		(btn == SwitchOff && state==safetyOn) ->
			Safety(target=safetyOff)
		<> 
		% We don't have to change anything
		Safety()
	
	% Interactions only possible when uC is on
	+ (state==safetyOn) ->
		% Battery is unsafe, turn off!
		aBattery(Unsafe).Safety(target=safetyOff);

% --------------------
% Steering procedure
% --------------------
sort steeringState = struct steeringOn | steeringOff | steeringNull;

proc Steering(state:steeringState) =
	% Process state changes
	%(target != steeringNull) ->
	%	Steering(target, steeringNull)
	
	% Process messages
	sum data:sVirtualCarState.r_VCS_steer(data).
		(data==On) ->
			Steering(steeringOn)
		<>	
		(data==Off) ->
			Steering(steeringOff)	
	
	% Interactions only possible when active
	+ (state==steeringOn) ->
		% Cruise control interactions
		sum btn:sCCButton.aCC(btn).
			% Do request to turn CC on
			(btn==Enable) ->
				s_ccEnable(Enabled)
			<>
			% Do request to turn CC off			
			(btn==Disable) ->
				s_ccEnable(Disabled)
;


% --------------------
% Lighting procedure
% --------------------
proc Lighting(state:sVirtualCarState) = 
	sum data:sVirtualCarState.r_VCS_light(data).
		(data==Off) ->
			aBrakeLighting(LightOff).Lighting(Off)
		<>
			Lighting()		

	+ (state==On) -> % and brake is true
		aBrakeLighting(LightOn).Lighting();

% --------------------
% Drive procedure
% --------------------
proc Drive(state: sVirtualCarState) = 
	sum data:sVirtualCarState.r_VCS_drive(data).Drive(data)
	
	% Process CC messages
	+ sum data:sCCState.r_ccEnable(data).
		aCCActive(data);

% --------------------
% Process definition
% --------------------
init
	allow({ 
		aCar, aBrakeLighting, aBattery, aCC, aVCS, 
		c_VCS, c_ccEnable
	},
	comm({ 
		s_VCS | r_VCS_steer | r_VCS_drive | r_VCS_light -> c_VCS,
		s_ccEnable | r_ccEnable -> c_ccEnable
	},
	Safety(safetyOff, safetyNull) || Lighting(Off) || Drive(Off) || Steering(steeringOff)
	));
