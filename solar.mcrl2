% --------------------
% Sort declarations
% --------------------
sort 
	sPedalState = struct Pressed | Released;
	sDNRPState = struct D | R | NP;
	sOnOffButton = struct SwitchOn | SwitchOff;
	sBatteryState = struct Unsafe | Safe | Full;
	sCCThreshold = struct BelowCCmin | AboveCCmin;
	sTurnOffThreshold = struct BelowTurnOffMax | AboveTurnOffMax;
	sDirection = struct Forwards | Backwards | Static;
	sCCState = struct Enabled | Disabled;
	sCCButton = struct Enable | Disable;
	sVirtualCarState = struct On | Off;
	sBrakeLighting = struct LightOn | LightOff;

map opposite: sDirection -> sDirection;
eqn opposite(Forwards)  = Backwards;
    opposite(Static)    = Static;
    opposite(Backwards) = Forwards;

% Maps the DNRP state to a direction
map direction: sDNRPState -> sDirection;
eqn direction(D)  = Forwards;
    direction(NP) = Static;
    direction(R)  = Backwards;

% --------------------
% Action declarations
% --------------------
act
	% Input actions from the user and environment
  	aGasPedal : sPedalState;
  	aBrakePedal : sPedalState;
  	aDNRP : sDNRPState;
  	aCar : sOnOffButton;
  	aBattery : sBatteryState;
  	aSpeed : sCCThreshold # sTurnOffThreshold # sDirection;

	aDirection: sDirection;
	aCCSpeed: sCCThreshold;
	aTurnOffSpeed: sTurnOffThreshold;

  	aCC : sCCButton;

  	% Output actions
  	aVCS : sVirtualCarState;
  	aMotorForce : sDirection;
	aBrakeLighting: sBrakeLighting;
	aCCActive: sCCState;

% --------------------
% Communication definitions
% --------------------
act s_VCS, r_VCS_steer, r_VCS_drive, r_VCS_light, c_VCS : sVirtualCarState;
act s_ccEnable, r_ccEnable, c_ccEnable: sCCState;
act s_battery, r_battery, c_battery : sBatteryState;
% --------------------
% Safety Procedure
% --------------------
sort safetyState = struct safetyOn | safetyOff | safetyNull;

proc Safety(state:safetyState, target:safetyState) =
	% State changes
	(target != safetyNull) ->
		((target==safetyOn) ->
			s_VCS(On).aVCS(On)
		<>
		(target==safetyOff) ->
			s_VCS(Off).aVCS(Off)
		).Safety(target, safetyNull)
	<> % If all states have been changes, do other things

	% Car on/off button interactions
	sum btn:sOnOffButton.aCar(btn).
		% The car is turned on
		(btn == SwitchOn && state==safetyOff) ->
			Safety(target=safetyOn)
		<> 
		% The car is turned off
		(btn == SwitchOff && state==safetyOn) ->
			Safety(target=safetyOff)
		<> 
		% We don't have to change anything
		Safety()
	
	% Interactions only possible when uC is on
	+ (state==safetyOn) ->
		% Battery is unsafe, turn off!
		aBattery(Unsafe).Safety(target=safetyOff);


% --------------------
% Steering procedure
% --------------------
sort steeringState = struct steeringOn | steeringOff | steeringNull;
%act steeringChange:steeringState;

proc Steering(state:steeringState) =
	% Process state changes
	%(target != steeringNull) ->
	%	steeringChange(target).Steering(target, steeringNull)
	
	% Process messages
	sum data:sVirtualCarState.r_VCS_steer(data).
		(data==On) ->
			Steering(steeringOn)
		<>	
		(data==Off) ->
			Steering(steeringOff)	
	
	% Interactions only possible when active
	+ (state==steeringOn) -> (
		% Cruise control interactions
		sum btn:sCCButton.aCC(btn).
			% Do request to turn CC on
			(btn==Enable) ->
				s_ccEnable(Enabled)
			<>
			% Do request to turn CC off			
			(btn==Disable) ->
				s_ccEnable(Disabled)
	);

% --------------------
% Lighting procedure
% --------------------
proc Lighting(state:sVirtualCarState) = 
	sum data:sVirtualCarState.r_VCS_light(data).
		(data==Off) ->
			aBrakeLighting(LightOff).Lighting(Off)
		<>
			Lighting()		

	+ (state==On) -> % and brake is true
		aBrakeLighting(LightOn).Lighting();

% --------------------
% Drive procedure
% --------------------
sort driveState = struct driveCC | driveOn | driveOff;
sort speedState = struct static | forwards | backwards | forwardsAboveCC | forwardsAboveOff | forwardsAboveCCAndOff;
%act driveChange:driveState;

proc Drive(state: driveState, speed:speedState, dir:sDirection, dnrp:sDNRPState, cc:sCCState, gp:sPedalState, bp:sPedalState, battery:sBatteryState) = 	
	% Process VCS updates
	sum data:sVirtualCarState.r_VCS_drive(data).
		(data==On) ->
			Drive(state=driveOn)
		<>
		(data==Off) ->
			Drive(state=driveOff)
	
	% Process battery status messages
	+ sum data:sBatteryState.r_battery(data).(
		Drive(battery=data)
	) % End battery status messages

	% Handle state changes when on
	+ (state==driveOn) -> (
		% Process CC messages
		sum data:sCCState.r_ccEnable(data).(
			Drive(cc=data)
		) % End CC messages
		
		% Process CC speed updates
		+ sum data:sCCThreshold.aCCSpeed(data).(
			% CC drops below cc min
			(data==BelowCCmin) -> (
				(speed==forwardsAboveCC) ->
					Drive(speed=forwards)
				<>
				(speed==forwardsAboveCCAndOff) ->
					Drive(speed=forwardsAboveOff)
			)
			<> 
			% CC goes above cc min
			(data==AboveCCmin) -> (
				(speed==forwards) ->
					Drive(speed=forwardsAboveCC)
				<>
				(speed==forwardsAboveOff) ->
					Drive(speed=forwardsAboveCCAndOff)
			)
			<>
			Drive()
		) % End cc speed updates

		% Process DNRP changes
		+ sum data:sDNRPState.aDNRP(data).(
			Drive(dnrp=data)
		) % End DNRP changes
		
		% process gas pedal changes
		+ sum data:sPedalState.aGasPedal(data).(
			(bp==Released && battery==Safe) -> ( % If the brake pedal is not pressed and it's safe
				aMotorForce(direction(dnrp)).Drive(dir=direction(dnrp), gp=data)
			) <> (% No actions, but update gp state
			Drive(gp=data)
			)
		) % End gas pedal changes

		% process brake pedal changes
		+ sum data:sPedalState.aBrakePedal(data).(
			(data==Pressed) -> % Brake pressed
				(battery==Full) -> aMotorForce(Static).Drive(dir=Static, bp=data) % battery is full, don't brake
				<> aMotorForce(opposite(dir)).Drive(dir=opposite(dir), bp=data)   % Brake
			<> % Brake released
			(gp==Pressed) -> % Gas is pressed
				aMotorForce(direction(dnrp)).Drive(dir=direction(dnrp), bp=data)
			<> % No actions, but update bp state
			Drive(bp=data)
		) % End brake pedal changes
	) % End state changes when on
;

% --------------------
% Process definition
% --------------------
init % TODO hide all but (comm and) output actions?
	allow({ 
		% Input actions
		aGasPedal, aBrakePedal, aDNRP, aCar, aBattery, aDirection, aCCSpeed, aTurnOffSpeed, aCC, 
		% Output actions
		aVCS, aMotorForce, aBrakeLighting, aCCActive,
		% Communication actions
		c_VCS, c_ccEnable, c_battery
	},
	comm({ 
		s_battery | r_battery -> c_battery,
		s_VCS | r_VCS_steer | r_VCS_drive | r_VCS_light -> c_VCS,
		s_ccEnable | r_ccEnable -> c_ccEnable
	},
		Safety(safetyOff, safetyNull) || 
		Lighting(Off) || 
		Drive(driveOff, static, Static, NP, Disabled, Released, Released, Safe) || 
		Steering(steeringOff)
	));
